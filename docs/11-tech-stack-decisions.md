# 11. 기술 스택 결정 및 이유 (Tech Stack Decisions)

이 프로젝트에서 선택된 주요 기술들과 그 선택 이유(Rationale)를 정리합니다.

## 1. 아키텍처: Clean Architecture + MVVM
- **이유**: 단순한 타이머 앱임에도 Clean Architecture를 적용한 이유는 **확장성**과 **관심사의 분리(SoC)**를 실천하기 위함입니다. 
    - **Domain Layer**: 비즈니스 로직을 프레임워크와 분리하여 순수 Kotlin으로 유지함으로써 테스트가 용이해졌습니다.
    - **Data Layer**: 데이터 소스(Room)의 변경이 도메인이나 UI에 영향을 주지 않도록 설계했습니다.
- **결과**: UI가 변경(예: 리디자인)되거나 DB 구조가 바뀌어도 핵심 비즈니스 로직(타이머 카운트다운, 세션 저장)은 그대로 유지될 수 있습니다.

## 2. 의존성 주입 (DI): Koin (v4.0.0)
- **이유**: Hilt에 비해 설정이 매우 간단하고(Boilerplate가 적음), Kotlin 개발자에게 더 직관적인 DSL(Domain Specific Language) 방식을 제공합니다. 가벼운 프로젝트 규모에 적합하다고 판단했습니다.
- **결과**: 컴파일 타임이 아닌 런타임에 의존성을 주입하여 설정 속도가 빠르고, `viewModel { ... }` 등의 DSL을 통해 Compose와의 통합이 매우 편리했습니다.

## 3. 선언형 UI: Jetpack Compose
- **이유**: 기존 XML 기반 방식보다 코드 양이 적고, 상태 관리(State Management)가 선언적이라 타이머의 실시간 상태 업데이트를 UI에 반영하기가 훨씬 직관적입니다.
- **결과**: `animateFloatAsState`를 사용하여 진행률 바의 애니메이션을 코틀린 코드 몇 줄만으로 구현할 수 있었으며, 상태 변화에 따른 자동 리컴포지션으로 복잡한 UI 업데이트 로직이 사라졌습니다.

## 4. 데이터베이스: Room
- **이유**: SQLite 위에서 컴파일 타임 쿼리 검사와 추상화 계층을 제공하여 안전한 데이터 처리가 가능하기 때문입니다. Google의 권장 라이브러리이자 CoroutinesFlow와의 완벽한 통합을 지원합니다.
- **결과**: `Flow<List<FocusSession>>`을 반환받아 기록 목록을 실시간으로 관찰(observe)하고 UI를 자동 갱신하는 반응형(Reactive) 아키텍처를 쉽게 구축했습니다.

## 5. 비동기 처리: Coroutines & Flow
- **이유**: 안드로이드의 비동기 작업을 간단하게 처리할 수 있으며, 특히 타이머처럼 지속적인 데이터 스트림이 필요한 기능에 `Flow`가 매우 적합했습니다.
- **결과**: `StartTimerUseCase`에서 1초마다 방출되는 Flow를 ViewModel에서 Collect하여 UI 상태를 갱신함으로써 깔끔한 비동기 로직을 구현했습니다.
